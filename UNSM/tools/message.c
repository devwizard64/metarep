#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <getopt.h>

#define JAPANESE
#define ENGLISH
#include <sm64/defchar.h>

#define ERR_UTF8    "invalid UTF-8 sequence"
#define ERR_SYNTAX  "invalid syntax"
#define ERR_LANG    "invalid language"
#define ERR_CHAR    "invalid character"
#define ERR_MODE    "mode already set"
#define ERR_NOLANG  "language not set"
#define ERR_NOMESS  "message not set"

static const char *fn;
static unsigned int ln;

static void error(const char *err)
{
	fprintf(stderr, "%s:%u: %s\n", fn, ln, err);
	exit(1);
}

static int UTF8_get(const char **strp)
{
	int n, ch;
	const char *str = *strp;
	char c = *str++;
	if      (!(c & 0x80)) n = 0, ch = c;
	else if (!(c & 0x40)) return -1;
	else if (!(c & 0x20)) n = 1, ch = c & 0x1F;
	else if (!(c & 0x10)) n = 2, ch = c & 0x0F;
	else if (!(c & 0x08)) n = 3, ch = c & 0x07;
	else                  return -1;
	for (; n > 0; n--)
	{
		c = *str++;
		if ((c & 0xC0) != 0x80) return -1;
		ch = ch << 6 | (c & 0x3F);
	}
	*strp = str;
	return ch;
}

typedef struct message
{
	struct message *next;
	char *info;
	unsigned char *str;
	int alloc, len;
}
MESSAGE;

static int mode;

static void msg_append(MESSAGE *msg, int c)
{
	if (msg->len >= msg->alloc)
	{
		msg->str = realloc(msg->str, sizeof(unsigned char)*(msg->alloc += 256));
	}
	msg->str[msg->len++] = c;
}

static void msg_print(MESSAGE *msg)
{
	int i, len;
	for (len = msg->len; len > 0 && msg->str[len-1] == CH_LF; len--);
	for (i = 0; i < len; i++)
	{
		printf("0x%02X,", msg->str[i]);
	}
	printf("0x%02X", CH_NUL);
}

/******************************************************************************/
/* JAPANESE                                                                   */
/******************************************************************************/

static const unsigned char ja_kana[] =
{
0x9E,0x6F,0x6E,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xF5,0xF6,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xF7,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xA5,0x40,0xA6,0x41,0xA7,0x42,0xA0,0x43,0xA8,0x44,0x45,0x45,0x46,0x46,0x47,
0x47,0x48,0x48,0x49,0x49,0x4A,0x4A,0x4B,0x4B,0x4C,0x4C,0x4D,0x4D,0x4E,0x4E,0x4F,
0x4F,0x50,0x50,0xA1,0x51,0x51,0x52,0x52,0x53,0x53,0x54,0x55,0x56,0x57,0x58,0x59,
0x59,0x59,0x5A,0x5A,0x5A,0x5B,0x5B,0x5B,0x5C,0x5C,0x5C,0x5D,0x5D,0x5D,0x5E,0x5F,
0x60,0x61,0x62,0xA2,0x63,0xA3,0x64,0xA4,0x65,0x66,0x67,0x68,0x69,0x6A,0xFF,0x6B,
0xFF,0xFF,0x6C,0x6D,0x42,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xD5,0x70,0xD6,0x71,0xD7,0x72,0xD0,0x73,0xD8,0x74,0x75,0x75,0x76,0x76,0x77,
0x77,0x78,0x78,0x79,0x79,0x7A,0x7A,0x7B,0x7B,0x7C,0x7C,0x7D,0x7D,0x7E,0x7E,0x7F,
0x7F,0x80,0x80,0xD1,0x81,0x81,0x82,0x82,0x83,0x83,0x84,0x85,0x86,0x87,0x88,0x89,
0x89,0x89,0x8A,0x8A,0x8A,0x8B,0x8B,0x8B,0x8C,0x8C,0x8C,0x8D,0x8D,0x8D,0x8E,0x8F,
0x90,0x91,0x92,0xD2,0x93,0xD3,0x94,0xD4,0x95,0x96,0x97,0x98,0x99,0x9A,0xFF,0x9B,
0xFF,0xFF,0x9C,0x9D,0x72,0xFF,0xFF,0x9B,0xFF,0xFF,0x9C,0xFC,0x9F,0xFF,0xFF,0xFF,
};

static const unsigned char ja_full[] =
{
0xFF,0xF2,0xFF,0xFF,0xFF,0xF3,0xFF,0xFF,0xF5,0xF6,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0xFF,0xFF,0xFF,0xFF,0xFF,0xF4,
0xFF,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,
0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,0x20,0x21,0x22,0x23,0xFF,0xFF,0xFF,0xFF,0xFF,
};

static const unsigned char ja_mark[] =
{
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x11,0x11,0x11,0x11,0x11,0x11,0x44,0x04,0x00,0x49,0x92,0x24,0x09,
0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x11,0x11,0x11,0x11,0x11,
0x11,0x44,0x04,0x00,0x49,0x92,0x24,0x09,0x00,0x00,0x00,0x00,0x00,0x41,0x10,0x00,
};

static void japanese(MESSAGE *msg, const char *str)
{
	int i, c, mark;
	while ((c = UTF8_get(&str)) != '\0')
	{
		unsigned char ch = CH_NUL;
		if (c < 0) error(ERR_UTF8);
		if (c >= 0x3000 && c < 0x3100)
		{
			ch = ja_kana[i = c-0x3000];
			if ((mark = ja_mark[i>>2] >> ((i&3)<<1) & 3))
			{
				msg_append(msg, CH_DAKUTEN + mark-1);
			}
		}
		else if (c >= 0xFF00 && c < 0xFF40)
		{
			ch = ja_full[c-0xFF00];
		}
		else switch (c)
		{
		case '\n': ch = CH_LF; break;
		case '%':
			switch (UTF8_get(&str))
			{
			case 'd': ch = CH_FMTINT; break;
			}
			break;
		case ')':
			if (str[0] == '(')
			{
				str += 1;
				ch = CH_RLPAREN;
			}
			break;
		case '<':
			if (str[0] == '-' && str[1] == '>')
			{
				str += 2;
				ch = CH_ARROW;
			}
			break;
		case '{':
			if ((c = UTF8_get(&str)) == '\0') break;
			if (UTF8_get(&str) != '}') break;
			switch (c)
			{
			case '+': ch = CH_COIN; break;
			case '-': ch = CH_STAR; break;
			case 'x': ch = CH_CROSS; break;
			case '.': ch = CH_NOSTAR; break;
			}
			break;
		case 0x2026: ch = CH_ELLIPSIS; break;
		case 0xFF01: ch = CH_BANG; break;
		case 0xFF05: ch = CH_PERCENT; break;
		case 0xFF08: ch = CH_LQUOTE; break;
		case 0xFF09: ch = CH_RQUOTE; break;
		case 0xFF1F: ch = CH_QUESTION; break;
		}
		if (ch == CH_NUL) error(ERR_CHAR);
		msg_append(msg, ch);
	}
}

static const unsigned char jas_kana[] =
{
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0x0E,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x0C,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x15,0xFF,0xFF,0xFF,0xFF,0x16,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x14,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x0D,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0x08,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0x01,0x13,0xFF,0x02,0xFF,0x19,0xFF,0xFF,0xFF,0x11,0xFF,0xFF,0xFF,0xFF,0x06,
0xFF,0xFF,0xFF,0x09,0xFF,0x18,0xFF,0xFF,0xFF,0x12,0xFF,0x04,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x1B,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0x0A,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x0F,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x10,0x03,0x05,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0x1A,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x0B,0xFF,0xFF,0xFF,
};

static void ja_select(MESSAGE *msg, const char *str)
{
	int c;
	while ((c = UTF8_get(&str)) != '\0')
	{
		unsigned char ch;
		if (c < 0) error(ERR_UTF8);
		if (c == '\n') continue;
		if (c >= 0x3040 && c < 0x3100) ch = jas_kana[c-0x3040];
		else if (c == 0xFF1F) ch = 23;
		else error(ERR_CHAR);
		msg_append(msg, ch);
	}
}

/******************************************************************************/
/* ENGLISH                                                                    */
/******************************************************************************/

static const unsigned char en_ascii[] =
{
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xD0,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0x9E,0xF2,0xFF,0xFF,0xFF,0xF3,0xE5,0x3E,0xE1,0xE3,0xFF,0xFF,0x6F,0x9F,0x3F,0xFF,
0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0xE6,0xFF,0xFF,0xFF,0xFF,0xF4,
0xFF,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,
0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,0x20,0x21,0x22,0x23,0xF5,0xFF,0xF6,0xFF,0xFF,
0xFF,0x24,0x25,0x26,0x27,0x28,0x29,0x2A,0x2B,0x2C,0x2D,0x2E,0x2F,0x30,0x31,0x32,
0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3A,0x3B,0x3C,0x3D,0xFF,0xFF,0xFF,0xF7,0xFF,
};

static void english(MESSAGE *msg, const char *str)
{
	int c;
	while ((c = UTF8_get(&str)) != '\0')
	{
		unsigned char ch = CH_NUL;
		if (c < 0) error(ERR_UTF8);
		if (c < 0x80) ch = en_ascii[c];
		switch (c)
		{
		case '%':
			switch (UTF8_get(&str))
			{
			case '%': ch = CH_PERCENT; break;
			case 'd': ch = CH_FMTINT; break;
			}
			break;
		case ')':
			if (mode == 2 && str[0] == '(')
			{
				str += 1;
				ch = CH_RLPAREN;
			}
			break;
		case '<':
			if (str[0] == '-' && str[1] == '>')
			{
				str += 2;
				ch = CH_ARROW;
			}
			break;
		case '{':
			if ((c = UTF8_get(&str)) == '\0') break;
			if (UTF8_get(&str) != '}') break;
			switch (c)
			{
			case '^': ch = CH_CU; break;
			case 'v': ch = CH_CD; break;
			case '<': ch = CH_CL; break;
			case '>': ch = CH_CR; break;
			case 'A': ch = CH_BA; break;
			case 'B': ch = CH_BB; break;
			case 'C': ch = CH_BC; break;
			case 'Z': ch = CH_BZ; break;
			case 'R': ch = CH_BR; break;
			case '+': ch = CH_COIN; break;
			case '-': ch = CH_STAR; break;
			case 'x': ch = CH_CROSS; break;
			case '*': ch = CH_BULLET; break;
			case '.': ch = CH_NOSTAR; break;
			}
			break;
		case 't':
			if (mode == 2 && str[0] == 'h' && str[1] == 'e')
			{
				str += 2;
				ch = CH_the;
			}
			break;
		case 'y':
			if (mode == 2 && str[0] == 'o' && str[1] == 'u')
			{
				str += 2;
				ch = CH_you;
			}
			break;
		case 0x2026: ch = CH_ELLIPSIS; break;
		}
		if (ch == CH_NUL) error(ERR_CHAR);
		msg_append(msg, ch);
	}
}

/******************************************************************************/

int main(int argc, char *argv[])
{
	int i, count = 0;
	const char *name = NULL;
	void (*lang)(MESSAGE *, const char *) = NULL;
	MESSAGE *root = NULL, **next = &root, *msg = NULL;
	FILE *fp;
	char *line = NULL;
	size_t linesize = 0;
	if (argc != 2)
	{
		fprintf(stderr, "usage: %s <txt>\n", argv[0]);
		return 1;
	}
	if (!(fp = fopen(fn = argv[optind], "r")))
	{
		fprintf(stderr, "error: could not open '%s'\n", fn);
		return 1;
	}
	for (ln = 1; getline(&line, &linesize, fp) > 0; ln++)
	{
		char *tok;
		switch (line[0])
		{
		case '#':
			break;
		case '$':
			if (strchr(line+1, ':'))
			{
				tok = strtok(line+1, ":");
				if (!strcmp(tok, "lang"))
				{
					tok = strtok(NULL, "\n");
					if      (!strcmp(tok, "ja"))        lang = japanese;
					else if (!strcmp(tok, "ja.select")) lang = ja_select;
					else if (!strcmp(tok, "en"))        lang = english;
					else error(ERR_LANG);
				}
				else if (!strcmp(tok, "table"))
				{
					if (mode) error(ERR_MODE);
					mode = 1;
					name = strdup(strtok(NULL, "\n"));
				}
				else if (!strcmp(tok, "message"))
				{
					if (mode) error(ERR_MODE);
					mode = 2;
					name = strdup(strtok(NULL, "\n"));
				}
				else error(ERR_SYNTAX);
			}
			else
			{
				tok = strtok(line+1, "\n");
				*next = msg = calloc(1, sizeof(MESSAGE));
				next = &msg->next;
				if (mode != 1) msg->info = strdup(tok);
				count++;
			}
			break;
		default:
			if (lang)
			{
				if (msg) lang(msg, line);
				else if (line[0] != '\n') error(ERR_NOMESS);
			}
			else error(ERR_NOLANG);
			break;
		}
	}
	free(line);
	fclose(fp);
	switch (mode)
	{
	case 0:
		for (msg = root; msg; msg = msg->next)
		{
			printf("#define %s ", msg->info);
			msg_print(msg);
			putchar('\n');
		}
		break;
	case 1:
		for (i = 0, msg = root; msg; i++, msg = msg->next)
		{
			printf("static unsigned char %s_%d[] = {", name, i);
			msg_print(msg);
			puts("};");
		}
		printf("unsigned char *%s[] =\n{\n", name);
		for (i = 0; i < count; i++) printf("\t%s_%d,\n", name, i);
		puts("\tNULL,\n};");
		break;
	case 2:
		for (i = 0, msg = root; msg; i++, msg = msg->next)
		{
			printf("static unsigned char %s_%d_str[] = {", name, i);
			msg_print(msg);
			puts("};");
		}
		for (i = 0, msg = root; msg; i++, msg = msg->next) printf(
			"static MESSAGE %s_%d = {%s, %s_%d_str};\n",
			name, i, msg->info, name, i
		);
		printf("MESSAGE *%s[] =\n{\n", name);
		for (i = 0; i < count; i++) printf("\t&%s_%d,\n", name, i);
		puts("\tNULL,\n};");
		break;
	}
	return 0;
}
